#!/usr/bin/python3

# Authors: Iain Lane, Martin Pitt

# This script uses the OpenStack Swift API to list all of the contents of our
# containers, diffs that against the local database, and then downloads any
# missing results.

# While in normal operation the download-results script is supposed to receive
# notification of completed jobs, in case of bugs or network outages etc, this
# script can be used to find any results which were missed and insert them.

import datetime
import io
import json
import logging
import os
import sqlite3
import sys
import tarfile
import time

import amqp
import swiftclient
from distro_info import UbuntuDistroInfo
from helpers.utils import (
    SqliteWriterConfig,
    amqp_connect,
    get_db_path,
    swift_connect,
)

LOGGER = logging.getLogger(__name__)

config = None
db_con = None
amqp_con = None


def list_remote_container(container_name, swift_conn, marker, limit=1000):
    LOGGER.debug("Listing container %s", container_name)
    _, list_of_test_results = swift_conn.get_container(
        container_name,
        marker=marker,
        limit=limit,
    )
    ret_me = {}
    for result in list_of_test_results:
        if result["name"].endswith("result.tar"):
            run_id = result["name"].split("/")[4]
            ret_me[run_id] = result["name"]
    return ret_me


def list_our_results(release):
    LOGGER.debug("Finding already recorded results for %s", release)
    c = db_con.cursor()
    # pylint: disable=line-too-long
    c.execute(
        "SELECT run_id FROM result INNER JOIN test ON test.id = result.test_id WHERE test.release=?",
        (release,),
    )
    return {run_id for (run_id,) in c.fetchall()}


def fetch_one_result(container_name, object_name, swift_conn):
    """Download one result URL from swift and add it to the DB"""
    global amqp_con
    (release, arch, _, src, run_id, _) = object_name.split("/")
    _, contents = swift_conn.get_object(container_name, object_name)
    tar_bytes = io.BytesIO(contents)
    try:
        with tarfile.open(None, "r", tar_bytes) as tar:
            exitcode = int(tar.extractfile("exitcode").read().strip())
            try:
                srcver = tar.extractfile("testpkg-version").read().decode().strip()
            except KeyError:
                # not found
                if exitcode in (4, 12, 20):
                    # repair it
                    srcver = "%s unknown" % (src)
                else:
                    raise
            (_, ver) = srcver.split()
            testinfo = json.loads(tar.extractfile("testinfo.json").read().decode())
            test_uuid = testinfo.get("uuid", "")
            duration = int(tar.extractfile("duration").read().strip())
            # KeyError means the file is not there, i.e. there isn't a human
            # requester
            try:
                requester = tar.extractfile("requester").read().decode().strip()
            except KeyError:
                requester = ""
    except (KeyError, ValueError, tarfile.TarError) as e:
        LOGGER.debug("%s is damaged, ignoring: %s" % (object_name, str(e)))
        return

    # parse recorded triggers in test result
    for e in testinfo.get("custom_environment", []):
        if e.startswith("ADT_TEST_TRIGGERS="):
            test_triggers = e.split("=", 1)[1]
            break
    else:
        LOGGER.error("%s result has no ADT_TEST_TRIGGERS, ignoring", object_name)
        return

    LOGGER.debug(
        "Fetched test result for %s/%s/%s/%s %s (triggers: %s): exit code %i",
        release,
        arch,
        src,
        ver,
        run_id,
        test_triggers,
        exitcode,
    )
    env_vars = []
    env_spec = ["all-proposed"]
    for env in env_spec:
        value = testinfo.get(env)
        if value is not None:
            env_vars.append("=".join([env, str(value)]))

    start = datetime.datetime.now()
    # Insert the write request into the queue
    while True:
        try:
            complete_amqp = amqp_con.channel()
            complete_amqp.exchange_declare(
                SqliteWriterConfig.writer_exchange_name,
                "fanout",
                durable=True,
                auto_delete=False,
            )
            write_me_msg = {
                "run_id": run_id,
                "version": ver,
                "triggers": test_triggers,
                "duration": duration,
                "exitcode": exitcode,
                "requester": requester,
                "env": ",".join(env_vars),
                "uuid": test_uuid,
                "release": release,
                "arch": arch,
                "package": src,
            }
            complete_amqp.basic_publish(
                amqp.Message(json.dumps(write_me_msg), delivery_mode=2),
                SqliteWriterConfig.writer_exchange_name,
                "",
            )
            return
        except Exception as _:
            time.sleep(3)
            now = datetime.datetime.now()
            if (
                now.timestamp() - start.timestamp()
            ) > SqliteWriterConfig.retry_time_limit:
                LOGGER.error("amqp connection seems unstable, exiting...")
                sys.exit(1)
            amqp_con = amqp_connect()


def fetch_container(release, swift_conn):
    """Download new results from a swift container"""
    container_name = "autopkgtest-" + release
    marker = None

    while True:
        try:
            last_marker = marker
            our_results = list_our_results(release)
            known_results = list_remote_container(container_name, swift_conn, marker)
            if not known_results:
                return
            marker = known_results[list(known_results.keys())[-1]]
            if last_marker == marker:
                return

            need_to_fetch = set(known_results.keys()) - our_results

            LOGGER.debug("Need to download %d items", len(need_to_fetch))

            for run_id in need_to_fetch:
                fetch_one_result(
                    container_name=container_name,
                    object_name=known_results[run_id],
                    swift_conn=swift_conn,
                )
        except swiftclient.exceptions.ClientException as e:
            LOGGER.error(
                "Something went wrong accessing container %s\nTraceback: %s"
                % (container_name, str(e))
            )
            return


if __name__ == "__main__":
    LOGGER.setLevel(logging.DEBUG)
    ch = logging.StreamHandler()
    if "DEBUG" in os.environ:
        ch.setLevel(logging.DEBUG)
    formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
    ch.setFormatter(formatter)
    LOGGER.addHandler(ch)

    releases = list(
        set(UbuntuDistroInfo().supported() + UbuntuDistroInfo().supported_esm())
    )
    releases.sort(key=UbuntuDistroInfo().all.index, reverse=True)

    amqp_con = amqp_connect()
    db_con = sqlite3.connect("file:%s%s" % (get_db_path(), "?mode=ro"), uri=True)
    swift_conn = swift_connect()

    try:
        for release in releases:
            fetch_container(
                release,
                swift_conn,
            )
    finally:
        if db_con:
            db_con.close()
