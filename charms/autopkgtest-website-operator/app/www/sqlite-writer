#!/usr/bin/python3

import datetime
import json
import logging
import os
import socket
import sqlite3

from helpers.utils import (
    SqliteWriterConfig,
    amqp_connect,
    get_db_path,
    get_test_id,
    init_db,
)

sqlite3.paramstyle = "named"

LAST_CHECKPOINT = datetime.datetime.now()

config = None
db_con = None


def check_msg(queue_msg):
    queue_keys = set(queue_msg.keys())
    if set(SqliteWriterConfig.amqp_entry_fields) == queue_keys:
        return True
    return False


def checkpoint_db_if_necessary(db_con):
    global LAST_CHECKPOINT
    now = datetime.datetime.now()
    with db_con:
        if (now - LAST_CHECKPOINT) > datetime.timedelta(
            minutes=SqliteWriterConfig.checkpoint_interval
        ):
            c = db_con.cursor()
            c.execute("PRAGMA wal_checkpoint(TRUNCATE)")
            LAST_CHECKPOINT = now


def process_message(channel, method, properties, body, db_con):
    if isinstance(body, bytes):
        body = body.decode("UTF-8", errors="replace")
    info = json.loads(body)
    logging.info("Message is: \n%s" % json.dumps(info))
    if not check_msg(info):
        logging.error(
            "Message has incorrect keys! Ignoring\n%s" % json.dumps(info, indent=2)
        )
        return
    # these aren't currently in the messages!
    # This block transforms the amqp message to a dictionary suitable
    # to be entered into the db
    info["test_id"] = get_test_id(
        db_con, info["release"], info["arch"], info["package"]
    )
    del info["release"]
    del info["arch"]
    del info["package"]
    with db_con:
        c = db_con.cursor()
        c.execute(
            (
                "INSERT OR REPLACE INTO result(test_id, run_id, version, triggers, duration, "
                "exitcode, requester, env, uuid) VALUES (:test_id, :run_id, "
                ":version, :triggers, :duration, :exitcode, :requester, :env, :uuid)"
            ),
            info,
        )
    logging.info("Inserted the following entry into the db:\n%s" % json.dumps(info))


def msg_callback(channel, method, properties, body, db_con):
    process_message(channel, method, properties, body, db_con)
    channel.basic_ack(delivery_tag=method.delivery_tag)
    checkpoint_db_if_necessary(db_con)


def main():
    logging.basicConfig(
        level=(logging.DEBUG if "DEBUG" in os.environ else logging.INFO)
    )
    db_con = init_db(get_db_path())
    amqp_con = amqp_connect()
    status_ch = amqp_con.channel()
    status_ch.exchange_declare(
        exchange=SqliteWriterConfig.writer_exchange_name,
        exchange_type="fanout",
        durable=True,
    )
    queue_name = "sqlite-writer-listener-%s" % socket.getfqdn()
    status_ch.queue_declare(queue_name, durable=True, auto_delete=False)
    status_ch.queue_bind(
        queue_name, SqliteWriterConfig.writer_exchange_name, queue_name
    )
    logging.info("Listening to requests on %s" % queue_name)
    status_ch.basic_consume(
        queue="",
        on_message_callback=lambda channel, method, properties, body: msg_callback(
            channel, method, properties, body, db_con
        ),
    )
    amqp_con.start_consuming()


if __name__ == "__main__":
    main()
